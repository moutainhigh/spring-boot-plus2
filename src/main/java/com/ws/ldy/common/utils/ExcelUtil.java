package com.ws.ldy.common.utils;import com.alibaba.fastjson.JSON;import io.swagger.annotations.ApiModelProperty;import org.apache.poi.hssf.usermodel.*;import org.apache.poi.ss.usermodel.*;import org.apache.poi.ss.util.CellRangeAddress;import org.apache.poi.xssf.usermodel.XSSFFormulaEvaluator;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import org.springframework.web.multipart.MultipartFile;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Field;import java.text.DecimalFormat;import java.text.SimpleDateFormat;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;@SuppressWarnings("all")public class ExcelUtil {    /**     * 解析上传的 Excel文件file数据，并返回     * <p>     *    返回数据：     *    List<Map<String, String>>     *    get(0)  =字段名     *    get(>0) =每一行的列表数据，可根据字段名 key读取每一行的数据     *  </P>     * @param file     * @return java.util.List<java.util.Map < java.lang.String, java.lang.String>>     * @author ws     * @mail 1720696548@qq.com     * @date 2020/5/5 0005 11:56     */    public static List<Map<String, String>> readExcle(MultipartFile file) {        List<Map<String, String>> rows = new ArrayList<>();        boolean isExcel2003 = true;        Workbook wb = null;        try {            // 上传路径            String uploadFilePath = file.getOriginalFilename();            //文件名            String uploadFileName = uploadFilePath.substring(uploadFilePath.lastIndexOf('\\') + 1, uploadFilePath.indexOf('.'));            //文件后缀            String uploadFileSuffix = uploadFilePath.substring(uploadFilePath.indexOf('.') + 1, uploadFilePath.length());            if (uploadFileSuffix.equals("xlsx")) {                isExcel2003 = false;            }            InputStream inputStream = file.getInputStream();            //FileInputStream inputStream = new FileInputStream((File) file);            // FileInputStream inputStream = new FileInputStream(file);            wb = isExcel2003 ? new HSSFWorkbook(inputStream) : new XSSFWorkbook(inputStream);            FormulaEvaluator evaluator = isExcel2003 ? new HSSFFormulaEvaluator((HSSFWorkbook) wb)                    : new XSSFFormulaEvaluator((XSSFWorkbook) wb);            // 获取表            Sheet sheet = wb.getSheetAt(0);            int rownum = sheet.getLastRowNum();            int cellNum = sheet.getRow(1).getLastCellNum();// 列数            Map<String, String> title = new LinkedHashMap<>();            for (int rowIndex = 1; rowIndex <= rownum; rowIndex++) {//				System.out.println(rowIndex);                Row row = sheet.getRow(rowIndex);                if (row == null || row.getCell(0) == null) {                    break;                }                Cell cell = row.getCell(0);                String value = "0";                if (cell != null) {                    if (cell.getCellTypeEnum() == CellType.NUMERIC) {                        if (HSSFDateUtil.isCellDateFormatted(cell)) {                            SimpleDateFormat sdf = null;                            if (cell.getCellStyle().getDataFormat() == HSSFDataFormat.getBuiltinFormat("h:mm")) {                                sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm");                            } else {// 日期                                sdf = new SimpleDateFormat("yyyy-MM-dd");                            }                            value = sdf.format(cell.getDateCellValue());                        } else {                            DecimalFormat df = new DecimalFormat("#.##");                            value = df.format(cell.getNumericCellValue());                        }                    } else if (cell.getCellTypeEnum() == CellType.BOOLEAN) {                        value = cell.getBooleanCellValue() + "";                    } else if (cell.getCellTypeEnum() == CellType.FORMULA) {                        CellValue cellValue = evaluator.evaluate(cell);                        if (cellValue.getCellTypeEnum() == CellType.NUMERIC) {                            DecimalFormat df = new DecimalFormat("#.##");                            value = df.format(cellValue.getNumberValue());                        } else {                            value = cellValue.getStringValue();                        }                    } else if (cell.getCellTypeEnum() == CellType.BLANK) {                        value = "0";                    } else if (cell.getCellTypeEnum() == CellType.STRING) {                        value = cell.getStringCellValue();                    } else if (cell.getCellTypeEnum() == CellType._NONE) {                        value = "0";                    }                }                if (value.equals("") || value.equals("0")) {                    break;                }                Map<String, String> rowValue = new LinkedHashMap<>();                // 读取数据                for (int cellIndex = 0; cellIndex < cellNum; cellIndex++) {                    cell = row.getCell(cellIndex);                    value = "0";                    if (cell != null) {                        if (cell.getCellTypeEnum() == CellType.NUMERIC) {                            if (HSSFDateUtil.isCellDateFormatted(cell)) {                                SimpleDateFormat sdf = null;                                if (cell.getCellStyle().getDataFormat() == HSSFDataFormat.getBuiltinFormat("h:mm")) {                                    sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm");                                } else {// 日期                                    sdf = new SimpleDateFormat("yyyy-MM-dd");                                }                                value = sdf.format(cell.getDateCellValue());                            } else {                                DecimalFormat df = new DecimalFormat("#.##");                                value = df.format(cell.getNumericCellValue());                            }                        } else if (cell.getCellTypeEnum() == CellType.BOOLEAN) {                            value = cell.getBooleanCellValue() + "";                        } else if (cell.getCellTypeEnum() == CellType.FORMULA) {                            CellValue cellValue = evaluator.evaluate(cell);                            if (cellValue.getCellTypeEnum() == CellType.NUMERIC) {                                DecimalFormat df = new DecimalFormat("#.##");                                value = df.format(cellValue.getNumberValue());                            } else {                                value = cellValue.getStringValue();                            }                        } else if (cell.getCellTypeEnum() == CellType.BLANK) {                            value = "0";                        } else if (cell.getCellTypeEnum() == CellType.STRING) {                            value = cell.getStringCellValue();                        } else if (cell.getCellTypeEnum() == CellType._NONE) {                            value = "0";                        }                    }                    if (rowIndex == 1) {                        // 所有字段名保存为小写 value.toLowerCase()                        rowValue.put(cellIndex + "", value.toLowerCase());                    } else {                        if (title.containsKey(cellIndex + "")) {                            rowValue.put(title.get(cellIndex + ""), value.replaceAll(",", "&prime;"));                        }                    }                }                if (rowIndex == 1) {                    title = rowValue;                }                rows.add(rowValue);            }        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        return rows;    }    /**     * Ecxel导出, 处理基础数据, 并调用 generateExcelDownload 方法进行生成并下载     * <p>     *     Excel 导出，传入任意 VO/实体类对象， 对象的所有字段必须添加 @ApiModelProperty , 和 注解的 value信息     *     1、自动获取@ApiModelProperty的 value为 EXcel的第一行数据     *     2、自动获取属性名为 EXcel的第二行数据     *     3、Excel的字段顺序 按 实体类的字段顺序来依次排序     * </p>     * @author wangsong     * @param ts 下载保存到excel数据     * @param sheetName 下载后的 excel 名称     * @param response     * @date 2020/9/7 0007 15:22     * @return boolean     * @version 1.0.0     */    public static <T> boolean exportExcelDownload(List<T> ts, String sheetName, HttpServletResponse response) {        List<String> fieldNameList = new ArrayList();            // 字段        List<String> fieldDescList = new ArrayList();            // 描叙        int sheetSize = 60000;                                   // Excel大小        // 生成字段+描叙        Class<?> classIs = ts.get(0).getClass();        Field[] fields = classIs.getDeclaredFields();        for (Field field : fields) {            ApiModelProperty annotation = field.getAnnotation(ApiModelProperty.class);            boolean required = annotation.required();            if (required != false) {                fieldDescList.add(annotation.value());                fieldNameList.add(field.getName());            }        }        List<Map<String, Object>> list = (List<Map<String, Object>>) JSON.parseObject(JsonUtil.toJSONString(ts), List.class);        ExcelUtil.generateExcelDownload(list, fieldNameList, fieldDescList, sheetName, sheetSize, response);        return true;    }    /**     *  具体生成并下载 Excel 的方法     *     * @param list           导出到excel数据--> 从第三行开始     * @param fieldNameList  [] 导出到excel文件里的表头字段备注    -->  对应excel的 第一行数据     * @param fieldDescList  [] 导出到excel文件里的表头字段属性名  -->  对应excel的 第二行数据     * @param sheetName      工作表的名称     * @param sheetSize      每个sheet中数据的行数,此数值必须小于65536     * @param response        java输出流 --> 保存到具体位置的文件     */    private static boolean generateExcelDownload(List<Map<String, Object>> data, List<String> fieldNameList, List<String> fieldDescList,                                                 String sheetName, int sheetSize, HttpServletResponse response) {        //        HSSFWorkbook workbook = new HSSFWorkbook();// 产生工作薄对象        if (sheetSize >= 65536) {            sheetSize = 65536;        }        double sheetNo = Math.ceil(data.size() / sheetSize);        for (int index = 0; index <= sheetNo; index++) {            // 产生工作表对象            HSSFSheet sheet = workbook.createSheet();            // 设置工作表的名称            workbook.setSheetName(index, sheetName + index);            // 生成标题（1行）            ExcelUtil.setTitle(workbook, sheet, new int[]{0, 0, 0, fieldDescList.size() - 1}, sheetName, true, true, 30, 16,                    IndexedColors.BLACK.index, IndexedColors.WHITE.index);            // 生成字段描叙列（2行）            ExcelUtil.setRow(workbook, sheet, 1, fieldDescList, true, true, 20, 16, 12,                    IndexedColors.BLACK.index, IndexedColors.WHITE.index);            // 生成字段属性列（3行）            ExcelUtil.setRow(workbook, sheet, 2, fieldNameList, true, false, 20, 16, 10,                    IndexedColors.BLACK.index, IndexedColors.WHITE.index);            // 写入每一行数 - 开始行号3 + 开始列号0            Integer startRow = 4;            Integer startCell = 0;            ExcelUtil.setData(workbook, sheet, fieldNameList, data, startRow, startCell, 18);        }        // 下载        ExcelUtil.download(workbook, response, sheetName);        return true;    }    /**     * 在Excel 中生成一行标题     * @author wangsong     * @param workbook     * @param sheet     * @param cellRangeAddress  起始行，截至行，起始列， 截至列  (索引)     * @param content 标题内容     * @param height            行高     * @param heightInPoints    字体大小  (默认12)     * @param bold              字体是否加粗  (默认false)     * @param color             字体颜色 ( 默认 IndexedColors.BLACK.index(黑))     * @param foregroundColor   背景颜色 ( 默认 IIndexedColors.WHITE.index(白))     * @param foregroundColor   字是否居中（默认不居中）     * @date 2020/9/27 0027 19:28     * @return void     * @version 1.0.0     */    public static void setTitle(HSSFWorkbook workbook,                                HSSFSheet sheet,                                int[] cellRangeAddress,  // 起始行，截至行，起始列， 截至列  (索引)                                String content,          // 内容                                boolean center,          // 是否居中(默认false)                                boolean bold,            // 是否加组（默认false）                                int height,              // 行高（默认20）                                int heightInPoints,      // 字体大小(默认12)                                short color,             // 字体大小(默认黑)                                short foregroundColor    // 背景颜色(默认白)    ) {        // =============样式start=============        HSSFCellStyle cellStyle = workbook.createCellStyle();        // 居中        if (center) {            cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);  // 水平居中            cellStyle.setAlignment(HorizontalAlignment.CENTER);        // 垂直居中        }        // 加边框        cellStyle.setBorderBottom(BorderStyle.THIN);//下边框        cellStyle.setBorderLeft(BorderStyle.THIN);//左边框        cellStyle.setBorderRight(BorderStyle.THIN);//右边框        cellStyle.setBorderTop(BorderStyle.THIN); //上边框        // 背景色        cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);//边框填充色        cellStyle.setFillForegroundColor(foregroundColor == 0 ? IndexedColors.WHITE.index : foregroundColor);        // 字体        HSSFFont font = workbook.createFont();        font.setFontHeightInPoints(heightInPoints == 0 ? 12 : (short) heightInPoints);       // 字体大小-（默认12）        font.setBold(bold == false ? false : true);                                          // 是否加粗-(默认false)        font.setColor(color == 0 ? IndexedColors.BLACK.index : color);                       // 颜色-(默认黑色)        cellStyle.setFont(font);        // =============样式end=============        // 合并单元格 CellRangeAddress构造参数依次表示起始行，截至行，起始列， 截至列        sheet.addMergedRegion(new CellRangeAddress(cellRangeAddress[0], cellRangeAddress[1], cellRangeAddress[2], cellRangeAddress[3]));        //HSSFRow rows = sheet.createRow(cellRangeAddress[0]);                     // 获取第一行（合并后的单元格）        HSSFRow rows = sheet.getRow(cellRangeAddress[0]);        if (rows == null) {            rows = sheet.createRow(cellRangeAddress[0]);        }        HSSFCell cell = rows.createCell(cellRangeAddress[2]);                      // 获取第几列的单元格(合并后的单元格)        rows.setHeight(height == 0 ? (short) (20 * 20) : (short) (height * 20));   // 设置高（默认20）        cell.setCellValue(content);                                                // 设置单元格内容        // 设置样式        cell.setCellStyle(cellStyle);    }    /**     *  在Excel 中生成一行数据库或实体类对应的字段列， 或字段描叙列     *  @param height            行高     *  @param heightInPoints    字体大小  (默认12)     *  @param bold              字体是否加粗  (默认false)     *  @param color             字体颜色 ( 默认 IndexedColors.BLACK.index(黑))     *  @param foregroundColor   背景颜色 ( 默认 IIndexedColors.WHITE.index(白))     *  @param foregroundColor   字是否居中（默认不居中）     */    public static void setRow(HSSFWorkbook workbook, HSSFSheet sheet, int rowNum,                              List<String> rowList,    // 需要生成的内容                              boolean center,          // 是否居中(默认false)                              boolean bold,            // 是否加组（默认false）                              int height,              // 行高（默认20）                              int width,               // 列宽（默认18）                              int heightInPoints,      // 字体大小(默认12)                              short color,             // 字体大小(默认黑)                              short foregroundColor    // 背景颜色(默认白)    ) {        // =============样式start=============        //居中        HSSFCellStyle cellStyle = workbook.createCellStyle();        if (center) {            cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);  // 水平居中            cellStyle.setAlignment(HorizontalAlignment.CENTER);        // 垂直居中        }        // 加边框        cellStyle.setBorderBottom(BorderStyle.THIN);//下边框        cellStyle.setBorderLeft(BorderStyle.THIN);//左边框        cellStyle.setBorderRight(BorderStyle.THIN);//右边框        cellStyle.setBorderTop(BorderStyle.THIN); //上边框        // 背景色        cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);//边框填充色        cellStyle.setFillForegroundColor(foregroundColor == 0 ? IndexedColors.WHITE.index : foregroundColor);        // 字体        HSSFFont font = workbook.createFont();        font.setFontHeightInPoints(heightInPoints == 0 ? 12 : (short) heightInPoints);       // 字体大小-（默认12）        font.setBold(bold == false ? false : true);                                          // 是否加粗-(默认false)        font.setColor(color == 0 ? IndexedColors.BLACK.index : color);                       // 颜色-(默认黑色)        cellStyle.setFont(font);        // =============样式end=============        // 获取第二行        HSSFRow row = sheet.createRow(rowNum);        // 行高        row.setHeight(height == 0 ? (short) (20 * 20) : (short) (height * 20));        // 产生单元格        for (int i = 0; i < rowList.size(); i++) {            // 创建第一行各个字段名称的单元格            HSSFCell cell = row.createCell(i);            // 设置样式            cell.setCellStyle(cellStyle);            // 给单元格内容赋值,设置单元格内容为字符串型            cell.setCellValue(rowList.get(i));            // 列宽            width = width == 0 ? 18 : width;            sheet.setColumnWidth(i, 256 * width + 184);        }    }    /**     * 在Excel 中生成内容(每一行的内容)     * @param workbook     * @param sheet     * @param fieldNameList 字段名, 所有数据的key， 对应实体类     * @param data          所有数据     * @param startRow      开始行号     * @param startCell     开始列号     * @param height        行高（默认20）     */    public static void setData(HSSFWorkbook workbook, HSSFSheet sheet, List<String> fieldNameList, List<Map<String, Object>> data, int startRow, int startCell, int height) {        for (int i = 0; i < data.size(); i++) {            // 写入行            int row = i + startRow;            // 当前行数据            Map<String, Object> map = data.get(i);            // 遍历字段            for (int j = 0; j < fieldNameList.size(); j++) {                // 写入列                int cell = j + startCell;                // 获取数据                Object value = map.get(fieldNameList.get(j + startCell));                // 写入                ExcelUtil.setValue(workbook, sheet, row, cell, value, height);            }        }    }    /**     *在Excel 在执行列写入数据     * @param workbook     * @param sheet     * @param fieldNameList 字段名, 所有数据的key，对应实体类     * @param data          所有数据     * @param startRow      开始行号     * @param startCell     开始列号     * @param height        行高（默认20）     */    public static void setValue(HSSFWorkbook workbook, HSSFSheet sheet, int row, int cell, Object value, int height) {        // 获取行        HSSFRow rows = sheet.getRow(row - 1);        if (rows == null) {            rows = sheet.createRow(row - 1);        }        // 行高        rows.setHeight(height == 0 ? (short) (20 * 20) : (short) (height * 20));        // 获取列（单元格）        HSSFCell cells = rows.createCell(cell);        // 写入数据, 数据为空录入空字符串        if (value != null) {            cells.setCellValue(value + "");        } else {            cells.setCellValue("");        }    }    /**     * 生成后下载 Excel     * @author wangsong     * @param workbook     * @param response     * @param sheetName 文件名     * @date 2020/9/27 0027 20:52     * @return void     * @version 1.0.0     */    public static void download(HSSFWorkbook workbook, HttpServletResponse response, String sheetName) {        // 文件名带上当前时间        DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");        sheetName += sheetName + "-" + df.format(LocalDateTime.now());        try {            // 信息头: 会告诉浏览器这个文件的名字和类型（必须设置）            response.setHeader("content-type", "application/octet-stream");            response.setContentType("application/octet-stream");            // 指定文件下载后的名称 --> 下载名中文乱码解决 --> java.net.URLEncoder.encode(fileXsl, "UTF-8")            response.setHeader("Content-Disposition", "attachment; filename=" + java.net.URLEncoder.encode(sheetName + ".xls", "UTF-8"));            // 放入响应体            ServletOutputStream output = response.getOutputStream();            output.flush();            workbook.write(output);            output.close();        } catch (IOException e) {            e.printStackTrace();            System.out.println("Output is closed ");        }    }    /**     * 列几种常用颜色获取     * @return     */    public static short getColor(int i) {        short[] arr = {                IndexedColors.YELLOW1.index,                IndexedColors.DARK_YELLOW.index,                // IndexedColors.LIGHT_YELLOW.index        };        int index = i % (arr.length);        return arr[index];    }}